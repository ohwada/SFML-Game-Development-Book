
cd /Users/ohwada/C++_SFML-Game-Development-Book/04_Input

g++ Source/*.cpp  -std=c++11 `pkg-config --cflags --libs sfml-all`  -I./Include 

======
In this chapter we aim to learn: 
- SFML events and their purpose as input 
- SFML real-time input and its difference from events 
- A command-based communication system to deliver events on our world
- How to dynamically bind keys at runtime


Polling events 
Generally speaking, events are objects that are triggered when something happens; mostly related to the user input. 
Events are a construct in the underlying operating system. 
                                                                                              

Keyboard events 
Now the defining feature of a PC, the keyboard. The keyboard generates events as the primary input device available to computers:

- For the event when the user presses down a key, we have the event type sf::Event::KeyPressed. 

- The event sf::Event::KeyReleased is the counterpart to KeyPressed; it is triggered when you release a key.

- Last, we have a little special event that SFML creates for your convenience. It is called sf::Event::TextEntered and is designed for receiving formatted text from the user.


======
Introducing commands

Here after, commands denote messages that are sent to various game objects. 
A command is able sent to various game objects. 
A command is able to alter the object and to issue orders such as moving an entity, firing a weapon, and triggering an explosion.   



=====
Command queues 
Now that the interface to distribute a command inside the scene graph is ready, we need a way to transport commands to the world and the scene graph. For this purpose, we write a new class CommandQueue. 
This class is a very thin wrapper around a queue of commands. A queue is a FIFO (first in, first out) data structure 




==================================== 

Handling player input 

Since this chapter is about input, it would be interesting to see how the commands can be exploited to react to the SFML events and real-time input. 
Up to now, player input has been handled in the Game class. But it deserves an own class, we call it Player.

The Player class contains two methods to react to the SFML events and real-time input, respectively:
- handleEvent
- handleRealtimeInput



Why a player is not an entity 
Well, the Player class can very much be considered as an entity, but in our case it is just a controller of entities. The class represents the player's input in the world of the game. 
In our gameplay, this entails only to manipulating a node in our scene graph. 


Take this with a grain of salt. 


 

=====




cd /Users/ohwada/C++_SFML-Game-Development-Book


SFML-Game-Development-Book
https://github.com/SFML/SFML-Game-Development-Book

 Game Development By Example
https://www.amazon.co.jp/SFML-Game-Development-Example-English-ebook/dp/B01061QAH4


