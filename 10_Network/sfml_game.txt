
cd /Users/ohwada/C++_SFML-Game-Development-Book/10_Network

g++ Source/*.cpp  -std=c++11 `pkg-config --cflags --libs sfml-all`  -I./Include 

=====
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-324.html

Chapter 10. Company Atop the Clouds- Co-op Multiplayer

After a long journey through to the topic, with lots of lessons learned, we have nowarrived at the last chapter. 
This is where we will handle a topic with growing importance in the modern times networking. 
This subject shall not be overlooked as itcan be very difficult to learn and implement. 
It is complicated enough for people toactually dedicate their careers on dealing exclusively with it. 
Usually network programmers are very experienced and good at it, so they can do it efficiently andprovide a good multiplayer gameplay to the end users.

Obviously, even if we wanted to, we couldn't teach every single thing about networkprogramming, good practices, and different implementations. 
However, we try topass on some knowledge on how to achieve a multiplayer experience, keepingthings as simple as possible. Based on the game we've built so far throughout thebook, we now add two new concepts: local cooperation and actual network game-play over the Internet.
The following is what this chapter has to teach essentially:
- Network sockets
- Client-server architecture
- Creating a protocol for communication
- Applying the concepts to our game
- Short introduction on latency problems
- Tips and tricks on cheating prevention

Let's now immerse ourselves in this complicated topic with a short introduction.

======
Playing multiplayer games
We've seen multiplayer games since computer games emerged—decades ago. Weare used to calling friends and family to play games with us, sometimes in a co-op-erative mode with common goals and other times for a competitive experience. Thepoint is that playing with someone else is usually lots of fun!




There was a time when the Internet barely existed, or simply put, people's connec-tions were too slow to actually have a good online experience. By then, it was veryusual for games to have a local multiplayer mode. This allowed a big trend for splitscreen and other types of local multiplayer gameplay. Local Area Network (LAN)multiplayer was also implemented as a way to make the experience more cooper-ative to players, and as a result, you could actually cooperate or fight with yourfriends over a cable or wireless network. Unfortunately, as time passed and the In-ternet became more powerful, the local multiplayer modes became less and lessused, and actual online multiplayer modes started to be the dish of the day. Eithermode is not extinguished or anything close to that, but the game market seems tomark a tendency for online games.

For the purpose of this topic, and to cover the networking field of programming, wewill be not be focusing on local modes, but rather will implement a fully-networkedconcept. However, fear not! We will show you a concept that game developers usea lot these days which allows you to actually have local co-op on top of a net-worked architecture!

====
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-326.html

Interacting with sockets
First of all, in order to go deeper in to network programming, we need to understandhow computers communicate with each other. This is the technological base thateveryone should know before trying to do anything with networking.This topic is not simple by itself, but it can be approached more easily without theneed to understand the deeper concepts, with the help of SFML's socket classes.A socket is essentially a gateway for data. You can visualize it as a link betweentwo applications. These applications are virtual, in the sense, they only matter in thenetwork, but are not necessarily different application processes, because you canuse sockets to connect an application to itself, as we do in this chapter. These sock-ets are the base of all networked programs; therefore, they are extremely important.
As sockets are a rather complicated concept, SFML provides classes to managethem.There are the following two main ways of communicating between multiple ma-chines

=========
TCP

Transmission Control Protocol (TCP) is a network convention for transferringdata between computers. This means that any operating system or platform thatis connected to the Internet and therefore uses the Internet Protocol (IP), whichTCP is built on top of, is able to communicate in a uniform way. This is why in anetworked application, we don't care who we are "talking" to, as long as the remotepeer can "speak" TCP/IP, communication is possible.For example, when you use your Internet browser, some websites will be hostedin Linux machines while others will be in Windows. Because they all use TCP/IP, itis not relevant what the operating system is, the website will be transferred to ourbrowser and we will be able to visualize it just the same.SFML provides two cross-platform classes for using TCP sockets:sf::TcpSocket and sf::TcpListener, which are exactly what we will use toachieve an online gameplay in this chapter. The sf::TcpSocket class initiates


TCP connections, while the sf::TcpListener class listens on a certain port foran incoming connection.Please note that TCP/IP is a high-level protocol in your operating system. Whenyou use it, many things are being managed by the OS, which takes some weightout of your back

=========
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-328.html


UDP
User Datagram Protocol (UDP) is another often used tool for network program-ming. Communicating data to another computer means simply pushing an array ofbytes to the network, so it is very similar to TCP/IP in this matter; however, UDPhas a very different set of rules.The first important thing about this protocol is to know that it is connectionless. Youcan't establish a tunnel of reliable data. You just take your data and send it some-where and it either gets there or not, and you are not notified of it.This may seem strange at first. You may think "Why would I want to send datathat may not even get there?" and it is normal to be suspicious about the utility of



such a network protocol at first, but you'll understand how powerful it can becomeif made right.The strong aspect about this protocol is that data is sent fast and there is no over-head on ensuring packet ordering or arrival. So, people usually implement a cus-tom protocol on top of UDP that allows sending some data reliably, by sending datacontinuously until a confirmation of arrival is received, while other data is sent un-reliably.Another important key difference of UDP and TCP is that UDP will not split a packetinto smaller parts when it exceeds the maximum limit of data size; you have to takecare of that manually. While in TCP you can neglect such things, in UDP, it's im-portant to keep packets small and efficient.

=======
Socket selectors
Another facility that SFML provides is the sf::SocketSelector class. This oneis not used in the topic's game, but it is very useful and will make your life easier ifyou choose to use it.This class will act as an observer for your sockets. It will hold pointers to everysocket you choose to register in it. Then, you may simply callsf::SocketSelector::wait() and it will return when one or more of the sock-ets receive some data. Once this happens, you handle the data somehow and callthe function again. This will ensure you always are notified of packets and handlethem in a simple and centralized manner.You can call sf::SocketSelector::add() for any type of socket and listener:sf::TcpListener, sf::TcpSocket, or sf::UdpSocket.

======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-330.html


Custom protocols

We've talked about TCP and UDP so far, which are two socket types that areused widely. Programmers don't usually program anything that is "lower-level" thanthose two, but very often build custom protocols on top of them.It is very useful to create such protocols as they allow us to abstract the more com-plex tasks of networking, and orient a network system into being more focused ona specific task. For a quick example, we can look at the FTP protocol. It allowssending files in a quick and simple way, because it has abstracted the more com-plex process of actually transferring that file over a lower-level protocol.A custom protocol is merely a set of rules set in stone of how communicationneeds to happen. When a custom protocol is created, it either sits on top of TCPor UDP or even both; but it automatically absorbs all advantages and limitations ofthe underlying protocol.There are many custom protocols that are used widely. For example, HTTP andFTP are two protocols that are used worldwide and are implemented on top ofTCP/IP. You use them all the time without knowing; for example, when you opena web page in your Internet browser, it was received through the TCP/IP networkprotocol, more specifically with the rules of the HTTP protocol.As if SFML's basic socket support weren't good enough, it also implementssf::Http and sf::Ftp, which you can use to communicate with any machinethat is implementing them too! This is a fantastic tool that you can use to your ad-vantage, for example, to directly transfer files to FTP servers, or to request webpages from remote hosts using HTTP. We won't cover such classes, as they go outof the scope of the topic, but to bring up your curiosity, you could use sf::Http tosend some data to a website that would handle it and do something useful with it.For example, that website could receive a high score information and immediatelylist it online for everyone to see!



We will be implementing one custom protocol as well in the upcoming sectionCreating the structure for multiplayer. It will be our own set of rules that are specificto our own game. It will lie on top of the TCP/IP protocol and you will just see howit can be used to make multiple instances of our game understand each other

=====
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-332.html


Data transport

We already know some things about how sockets behave and their inner workings,but we only talked about sending and receiving data in an abstract way. We referredto the data as arrays of bytes, which we simply send and receive, but how is it done?Indeed, what is passed on through the network is merely a block of data, a collectionof raw bytes. Therefore, it must be sent in a way that can be read again by the re-mote machine. Your data could be anything, text, numbers, images, sound, or prettymuch anything that is digital.For this, we pack and unpack our data into a byte array when sending/receiving it!When we use the term packet, we refer to a collection of bytes, which contain oneor more primitives (integers, floats, and others). This is very efficient from the per-spective that we don't have additional overhead for sending multiple primitives; theyall go at once in the same byte array. However, we have a per-packet overhead,namely the packet headers that are required by the lower-level protocols (most not-ably IP and TCP/UDP).Packing and unpacking is not a complicated thing to do, but can be troublesome toget right when done from scratch.To add complexity to this task, you can't make assumptions on what byte orderingsystem the target machine is using. There are big-endian and little-endian operatingsystems, which mean a different ordering of bytes in memory. You can look at it asreversing the order of the bits of a variable. Therefore, for example, the number 3in a little-endian system, when transferred to a big-endian one is not the number 3anymore, as the bits were reversed. This needs to be taken into account.Luckily, SFML has also solved this! You can and should use the sf::Packet classto address this issue. It is very simple to work with and it will make your life easier inevery way, as opposed to implementing it all from scratch. If properly understandingthe socket functionality is half of the work, understanding packets would be the oth-er half into making a good networked application.The following code shows how to pack some data and send it:

======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-334.html


Network architectures

Regardless of socket types and protocols, games take different approaches in thearchitecture of the multiplayer mode.We call the playable game application a client, network-wise, and this part of thebook concerns how clients communicate with each other and who they communic-ate with.There are at least two major approaches to a networked simulation.

Peer-to-peer
This architecture was and still is used in online games; however, it fits a very specificset of purposes and is used less widely than its counterpart client-server architec-ture.Nevertheless, its importance should be noticed and mentioned every time network-ing is the topic. What defines this architecture is essentially the fact that every gameclient in the simulation connects to each other. You can see it in the following figure:

These inter-connections between all the clients, which somehow resemble aspider's web, mean that every client has a connection with every client. This way,they effectively communicate correctly, allowing chatting with each other, seeingeach other's movements, and other actions. When a client means to do something,such as when the jump key is pressed and the character should jump, it notifiesevery other client of this, so they can see it happen too.

However, while this approach can be efficient, as the network processing is doneamong all clients, it introduces a nasty set of disadvantages that unfortunately can'tbe avoided.

======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-335.html

Client-server architecture
Alright, this is a very, very important subject. This is nearly the standard as far asmultiplayer gaming goes. Learn this concept well and you're gold. This will be par-ticularly useful for nearly all networking tasks you will be doing and not exclusivelygames.

Why is it so important? First, because it allows a central instance to controleverything, and therefore provides the possibility to implement means of security.The following figure shows how computers are laid in such architecture:

Here, you see there is a central server, or group of servers (distributed systems)that communicate with all the clients. Now, a client does not know, under anycircumstances, about other client's address or information. The server acts as aproxy, or a bridge between the client's communications. However, saying the serv-er is merely a bridge for communication is a reductive view of what it really does.

=========
Authoritative servers

In reality, having one server manage all of the clients and be in charge of all theircommunications easily puts the server application under a heavy processing andnetworking load. It is hard to develop and maintain efficient and fast servers thatcan hold many clients at once. However, this cost is easily compensated by theadvantages this architecture inherently gives us. The most notable feature is theauthority of the server, entirely preventing the cheating and exploiting by the play-ers.

======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-337.html

Creating the structure for multiplayer
You must be fed up with networking theory by now, and you actually want to see some code! 
Right, it is now time to start the concrete implementation of our gameserver.
In order to extend our game and add an online mode to it, we went ahead and created a new state MultiplayerGameState, which is very similar to GameState atfirst. 
In the following code snippet, you see the important parts of the class defini-tion. 

As you see, the three typical state-related methods to draw, update, and handleevents are again there, as well as the variables for the world, window, and textureholder. Several variables are new related to the management of different playersand socket connections


We changed the main menu appropriately to accommodate the newly createdHost and Join options. 

To avoid creating one state for each of those options,we created a custom constructor for MultiplayerGameState, which takes aparameter clearly stating whether this state will be hosting or just joining. You cansee those changes in StateStack.cpp. 
Because both modes are almost equal,it wouldn't even make sense to have another state. The only difference is thatif the state is the host, it will launch a background server in its constructor andshut it down again in its destructor! 
By this logic, we can say that MultiplayerGameState is the client-side of our application and GameServer is the server-side

=======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-339.html

Working with the Server

Now it is time to put our hands on the actual server! 
We will be dissecting theGameServer class to understand properly what is going on.

=======
Server thread

To begin with, we decided to put the server in a separate thread. 
This is very usefulin many ways. 
For once, server processing can be intensive and could hurt theframe rate on the client. 
On the other hand, if the server is running on a parallel thread, aside from improving its performance, it also allows it to perform blocking calls whenever necessary, and the game keeps running smoothly. 
Another plus in this approach is that our server does not communicate programmatically with the cli-ent, it communicates only via network; therefore, we don't even need to care aboutsynchronization between the two. 
It is just like as if server is running on a different application!As we have already introduced sf::Thread before in Chapter 5, Diverting theGame Flow - State Stack, we will skip that topic here. It is important to notice thatGameServer::executionThread() is the thread function and that it starts run-ning when GameServer gets constructed, and is stopped before it gets destructed.Now, inside GameServer::executionThread() is where all the magic happens.First rule is that while executionThread() doesn't return a value, the parallelthread is alive. There are three main logical steps in the server thread: initialization,the server loop, and termination. Take a look at this pseudo-code:void GameServer::executionThread()

{initialize();while(!timeToStop) loop();shutdown();}

Not unlike the client-side of the game, we must do the appropriate things in the prop-er places. In the initialization phase, just when the server thread starts, we are going





to tell the sf::TcpListener socket to start accepting new connections. 
This is what allows the players to join our server. 
Also, we initialize some timing variableshere to be used in the server loop later. 
As you may notice, there isn't that much toinitialize at this point as the world is still empty without any ally or enemy aircraft,and the basic variables are initialized by the constructor.
Then, we enter the server loop, which will simply keep executing until the whileloop ends, either by a forced termination of the thread, which is not recommended,or by setting the timeToStop Boolean variable to true, effectively ending thewhile loop at the end of the next step

======
Server loop

Without a doubt, this part is the most important, and while many programmers takedifferent paths in the process of creating a server loop, we did it in a way that is notunusual to see across programs. The following is the simplified anatomy of eachstep in the loop:

The first two functions are going to respectively handle all incoming traffic from theconnected peers and accept new connections, if there are any. Then, updateLo-gic() will be very similar to the client's update() functions; it will simply perform


the evolution of data over time, to keep the server's state always up-to-date. Thenext function, tick(), is very similar to the previous update step, but usually ex-ecutes fewer times and is used to send a snapshot of the server's state to the cli-ents. In our case, we send updates to the clients 20 times per second. We may callthis frequency the tick rate.Just to be clear, the main reason tick() and updateLogic() functions are notmerged is because they run at different rates. This is to save processing time andnetwork bandwidth, as sending too many packets too often would just put a heavyload on the network with no benefits. Ideally, we want to send as little data as pos-sible but making sure it is enough to accomplish the gameplay demands. This way,updateLogic() runs a lot faster to always keep the data as refreshed as pos-sible, while tick() only performs as few times as necessary to make sure theclient has an accurate version of the server state locally at all times.Finally, the call to sf::sleep() is entirely optional; however, it is not a bad ideato tell the thread to sleep a bit and let the client's thread take the processor for itselffor a little while. The bigger time you pass to sf::sleep(), the less time will bespent on server's tasks. It will be fine just until the server has too many tasks toperform and too little time to do them.Before heading to the depths of these functions, let's rest a bit by looking at thedata structures we will use, and how they are laid out

=====
Peers and aircraft

The multiplayer version of our game is a little different than its single-player coun-terpart. Now, each client can have one or two local aircraft objects, but many cli-ents can be connected simultaneously. Though, one client is always one peer inthe eyes of the server. A peer by itself can contain multiple aircraft. Therefore theserver always knows how many clients are connected, how many aircraft are in thegame and which peers they belong to:



The preceding code snippet shows the structure of RemotePeer, which is de-clared inside GameServer. The constructor merely initializes the peer's data toan invalid state, which by itself means the peer is instanced, but not yet pointingto an actual client. The socket variable is the TCP socket we mentioned earlier inthe chapter that we will use to communicate exclusively with a specific peer. ThelastPacketTime variable always contains the timestamp of the last packet re-ceived from that peer. This is used to deduct disconnections and timeouts by asimple rule: If the peer did not send any data after n seconds, kick it out becausesomething is wrong, as there are packets that the client has to compromise to sendregularly.The aircraftIdentifiers variable is an interesting one. It holds a list of IDs ofall the planes that belong to a specific peer. There is a good reason there is onlyan integer here: All the aircraft data is centralized in GameServer, and is easilyreferred to in there by using this integer ID, if needed.The ready Boolean variable refers exactly to the valid or invalid state of the peerconnection. It only becomes true after a successful connection and sending theworld state to the newly connected socket.The timedOut variable is just a flag that is set in the server logic to tell thehandleDisconnections() function that this peer needs to be erased.


The preceding code snippet shows where all the peers are stored, as well as thementioned aircraft data. mAircraftCount will always contain the total of human-controlled aircraft in the world at a time. Their data can be queried using mAir-craftInfo, through the struct declared as follows:


Yes, it is very simple. It only holds the position of the aircraft and the set of real-time actions the player is currently performing, such as moving and shooting.The size of mPeers is always the number of truly connected peers plus one.That extra peer that is never valid exists for a single purpose: To become validonce a new connection is established. And when that peer becomes valid, anotherinvalid one is created for the same purpose! This way, new peers are alwaysadded at the end and can be removed from the middle of std::vector withoutproblems, as the "standby" peer is always guaranteed to be at the last positionof the array. The number of truly connected peers can be queried with mCon-nectedPlayers. There is a chance you are still struggling to understand whythis extra peer is kept in the vector. Well, it had to be somewhere sincesf::TcpListener::accept() requires it, so it was just a decision as any otherwhen designing the code. Eventually, we insert the peer to the vector anyway, so itis reasonable to construct it there in advance.


The aircraft identifier counter is an integer that starts at 1 and grows by one everytime a new aircraft is added to the world. This guarantees that no matter how manyaircraft join and leave the world; new ones will always be assigned new unique



identifiers. Also, we would like to emphasize the difference between mConnec-tedPlayers and mAircraftCount. While the former refers to unique connec-ted peers or clients, the latter refers to unique airplanes present in the game.

=======
Hot Seat

Our approach allows the handling of multiple aircraft in a single peer. This makesour system inherently apt to handle what the gaming community refers to as HotSeat multiplayer. It really only stands for local cooperative gameplay, where thesame gaming machine is used by more than one player in a single game session.For this reason, our sample allows this mode at any time. As soon as you pressthe Return key, a second aircraft will join the game, and while you're actually play-ing a networked game with a real server, it will seem like one of those old-schoolgame sessions, where you would be the friend or foe of your friends throughoutthe game.

======
Accepting new clients

About accepting incoming connections, the responsible object to do this is ourmListenerSocket, which is of type sf::TcpListener. As long as the mCon-nectedPlayers value is below mMaxConnectedPlayers, that connection isaccepted. If this condition is not met, the socket entirely stops listening for newconnections, effectively rejecting them all.The sf::TcpListener::accept() function is where the connection actuallysucceeds, generating a valid tunnel for communication between the peer and theserver. It takes an already-instanced socket which is initialized in case of success.Conveniently, we have that extra peer always allocated for this purpose! That's ex-actly what we use to test if an incoming connection has arrived. The following iswhat we do:


An important remark in this situation is that sockets have two modes: blocking andnon-blocking. The main difference is that the first will hold the program from con-tinuing execution while waiting for incoming connections/packets/responses, andthe latter will never block execution, keeping the fluidity of the program. It is goodto remember that we set our mListenerSocket as a non-blocking socket. Thisis due to having a fast execution of the server loop without any more threads.The calls to sf::TcpListener::accept() that are constantly happening, re-turn immediately stating whether there are new connections or not. All other serversockets are set to non-blocking as well for the same reason.So, what does it mean when sf::TcpListener::accept() returns a success-ful response? It means a new client is trying to join, whether it's the first or the nth,whether it's local or in another country, we treat it the same way. There are a fewoperations we must make in order to set up a new valid peer and attribute a newaircraft to it



First, we use our identifier counter to get a new ID for the new aircraft, then, we bind to it some aircraft data, namely its initial position. Then we assign that aircraftto belong to the newly created peer, using the aircraftIdentifiers struct.Now, there are the following four things that we send to the client:

- The order to spawn itself immediately
- The current state of the world with all the current aircraft
- How big the map is
- How much distance has been travelled already inside the mapAlso, we notify every other peer that this aircraft is joining, so they are aware of anew player. 
Finally, and not as a mandatory step, we use broadcastMessage()to send a message to all previously connected peers, informing them of the newplayer that just joined!The first thing in the list is actually the last being sent for a reason: When the clientspawns the aircraft, it expects the world to be configured already with the currentstate. This is where TCP sockets come in very useful, as they help us ensure theordering of the packet arrival, making our game logic more consistent.To finish, we just increment the proper peer and aircraft counters, that is, mCon-nectedPlayers and mAircraftCount respectively, and set the currenttimestamp to the peer, so it is not prematurely disconnected by lack of activity.After setting mPeers.last()->ready to true, we are ready to instance the newinvalid peer for the next connection. This happens if there are still available slots

=======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-339.html

Working with the Server

Now it is time to put our hands on the actual server! We will be dissecting theGameServer class to understand properly what is going on.Server threadTo begin with, we decided to put the server in a separate thread. This is very usefulin many ways. For once, server processing can be intensive and could hurt theframe rate on the client. On the other hand, if the server is running on a parallelthread, aside from improving its performance, it also allows it to perform blockingcalls whenever necessary, and the game keeps running smoothly. Another plus inthis approach is that our server does not communicate programmatically with the cli-ent, it communicates only via network; therefore, we don't even need to care aboutsynchronization between the two. It is just like as if server is running on a differentapplication!As we have already introduced sf::Thread before in Chapter 5, Diverting theGame Flow - State Stack, we will skip that topic here. It is important to notice thatGameServer::executionThread() is the thread function and that it starts run-ning when GameServer gets constructed, and is stopped before it gets destructed.Now, inside GameServer::executionThread() is where all the magic happens.First rule is that while executionThread() doesn't return a value, the parallelthread is alive. There are three main logical steps in the server thread: initialization,the server loop, and termination. Take a look at this pseudo-code:


Not unlike the client-side of the game, we must do the appropriate things in the prop-er places. In the initialization phase, just when the server thread starts, we are going

for peers in the server, otherwise, the mListenerSocket socket will go back to asleeping state, not listening to new connections anymore. It can indeed come backto life later, if users leave in the meanwhile

======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-347.html

Handling disconnections

Every time the server checks the peers for incoming packets, it makes a quick ana-lysis of whether a peer hasn't sent anything in a very long time. If that is the case,we consider that peer timed out, and it is effectively kicked out of the server alongwith all its aircraft.There are two main scenarios for disconnection; the first is when a user explicitlyquits the game, intentionally leaving the simulation by sending a specific packetwarning the server. The other is when something is wrong with the network, andthe packets are not arriving anymore—the situation that we know as timeout.If in that situation, at least one peer is marked for removal by setting itsmTimedOut flag to true, handlingDisconnections() is called, and does thefollowing


As you can see, it iterates over every peer, and for those who are flagged to beremoved, it warns every peer that those aircraft are going to disappear. Then, theproper counters are decremented again and mAircraftInfo is partially clearedso it doesn't contain any more data for the erased planes. The peer is then effect-ively released from the mPeers list. Finally, if it's necessary, we resurrect the listen-er socket to start listening again for new users and always send an "ally disconnec-ted" broadcast message, such that the other users are aware of what happened.

====
Incoming packets
We saved this part for last, as it is very important and a little more complex. We willnow inspect the behavior of sending actual packets and receiving them. We usethe exact same concepts we previously talked about for packing and unpackingsf::Packet. However, every packet must conform to some rules in order for boththe client and the server to understand what is supposed to happen in the presen-ce of each packet.All packets have a fixed identifier, sized as a sf::Int32 for coherence. This iden-tifier is what explicitly tells us what the packet contains and what it brings inside:

sf::Packet packet;packet << static_cast<sf::Int32>(identifier);

The rest of the packet data depends on what the identifier actually is. All identifierswe defined are under NetworkProtocol.hpp. All packets that originate in theserver are under the Server, and all the packets that come from the client are inthe Client namespace. The following is a code snippet with those identifiers:



By making sure that both clients and server use the same "network language" bypacking and unpacking the transferred data the same way and conforming to thespecification of every packet type, we achieve a sane and logical communicationprotocol, which we call the network protocol, custom-made to fit our needs! 
As stated earlier in the chapter, defining such a protocol is, in many ways, similar tohow other protocols were defined, such as HTTP and FTP.
Now lets understand how packets are handled in code


What we do is essentially traverse all the properly connected peers, and for eachpeer, we read as many packets as there are available using the non-blockingsf::TcpSocket::receive() function.For each packet received, we call handleIncomingPacket() and reset thetimestamp in the corresponding peer, so it doesn't time out. After receiving thepacket, we test this timestamp against a predefined timeout limit. If no packetwas received for at least mClientTimeoutTime, then the Boolean detec-tedTimeout flag is set, allowing a call to handleDisconnections(), which willremove the peer that timed out, as it was marked for removal by setting timedOutto true on the peer.Now, let's take a look at how we handle a packet from the client


As we mentioned, the packet identifier, which clearly states the packet type, de-pending on whether it was sent by the client or the server, is fixed to be always asf::Int32 value, so we begin by unpacking that header. Now, since that numbermatches directly with the members of the corresponding enumerator, we perform aswitch on it. The preceding code snippet does not contain all cases that we handle,so we can better understand the flow of the server logic and later analyze eachpacket properly.This is exactly what defines the interaction between peers and the rules of thegameplay in conformance with the network protocol we created. For example,when we get a packet from the client of type Client::PlayerEvent, we alreadyknow from the "specification" that we can find in the packet's data two sf::Int32variables: the aircraft identifier and the action identifier that matches directly theone in the Player.hpp file. This way, when we read such a packet, we can broad-cast it back to all peers so they all make the aircraft X perform action Y at the sametime.


- SpawnSelf: This takes a sf::Int32 value for the aircraft identifierand two float values for its initial position. It is used to order the peer tospawn its player one's aircraft.
- InitialState: This takes two float values, the world height and theinitial scrolling in it, then a sf::Int32 value with the count of aircraft inthe world; then for each, it takes a sf::Int32 identifier and two floatvalues with the position of the airplane.
- PlayerEvent: This takes two sf::Int32 variables: the aircraft iden-tifier and the action identifier, as declared in Player. 
This is used toinform all peers that plane X has triggered an action.
- PlayerRealtimeChange: This is same as PlayerEvent, but forreal-time actions. 
This means that we are changing an ongoing state toeither true or false, so we add a Boolean value to the parameters.
- PlayerConnect: This is same as SpawnSelf, but indicates that anaircraft from a different client is entering the world.
- PlayerDisconnect: This takes one sf::Int32 value with the air-craft identifier to be destroyed.
- AcceptCoopPartner: This is used to tell the client that it is free tospawn another local plane. It takes a sf::Int32 value and two floatvalues with the identifier of the aircraft to be spawned and its initial po-sition.
- SpawnEnemy: This takes one sf::Int32 value with the type of theaircraft as declared in Aircraft class and two float values indicatingwhere the enemy should spawn.
- SpawnPickup: Similar to SpawnEnemy, but applies for the spawn ofa pickup in the world. 
The first sf::Int32 value to be packed is de-clared inside the Pickup class.
- UpdateClientState: This takes one float value with the currentscrolling of the world in the server, and then a sf::Int32 value with the aircraft count. 
For each aircraft, it packs one sf::Int32 value with the identifier and two float values for position.
- MissionSuccess: This has no arguments. It is simply used to informthe client that the game is over.


Comments are probably not needed, as fixed time steps were already explainedin Chapter 1, Making a Game Tick. All that is being actually updated in here is themBattleFieldRect variable, which scrolls upwards into the end of the level—anexact replica of what happens in the client with the world view.Simple enough, let's now look at a more important code, the ticks, which we use tomaximize the synchrony between both server and client. Let's use some pseudo-code


The first step is to send to all clients the current snapshot of the server's state,which consists of the current scrolling of the world (mBattleFieldRect.top +mBattleFieldRect.height) and the positions of all aircraft.

======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-353.html

Understanding the ticks and updates

In the pseudo-code, we referred to the updateLogic(), now let's take a look atwhat it actually does

========
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-351.html

Studying our protocol
Let's attempt a deeper understanding of the logic of our server by checking whateach server packet exactly means.Every packet in the Server::PacketType enum is formed by the bullet's title asits identifier. That assumed, we explain the following packed parameters:• BroadcastMessage: This takes a std::string and is used to senda message to all clients, which they would show on the screen for someseconds.
 
＝＝＝＝＝＝＝＝
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-353.html

Understanding the ticks and updates

In the pseudo-code, we referred to the updateLogic(), now let's take a look atwhat it actually does:



Comments are probably not needed, as fixed time steps were already explainedin Chapter 1, Making a Game Tick. All that is being actually updated in here is themBattleFieldRect variable, which scrolls upwards into the end of the level—anexact replica of what happens in the client with the world view.Simple enough, let's now look at a more important code, the ticks, which we use tomaximize the synchrony between both server and client. Let's use some pseudo-code:


The first step is to send to all clients the current snapshot of the server's state,which consists of the current scrolling of the world (mBattleFieldRect.top +mBattleFieldRect.height) and the positions of all aircraft.



About the aircraft positioning, it is important to notice that the server is not an au-thority over the movement of aircraft, but rather an agent in their synchronization.When you control your aircraft with the keys, the server will obey and register yournewly obtained positions and the client won't overwrite its own local plane loca-tions with the incoming server data. Therefore, we can assume that each client isresponsible for the positions of its own aircraft. The server will however dispatcheach client's positions to all others!Then, checkMissionEnd() corresponds to the code that will check if all aircraftare near enough to the end of the level for the Server::MissionSuccess pack-et to be delivered, effectively showing a message in the client and quitting to themenu. This check is performed by checking if all the aircraft positions are betweenthe effective end of the level and a given offset, provided in the endLevel con-stant.After that, both spawnEnemies() and spawnPickups() functions will be re-sponsible for making enemies and pickups appear at random intervals and at ran-dom locations, by using the randomInt() utility function.

＝＝＝＝＝
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-355.html

Taking a peek in the other end - theclient

We have looked in the server extensively and have hopefully clarified all systemsand learned how they come together to form a single object that services a lot ofclients at once, and potentially even more aircraft! Now let's look at the other end,the client, and see how we took a jump from a single-player-only game into a fully-networked game.Let's examine the MultiplayerGameState constructor first:



We need to deduce which IP to communicate with, in order to successfully join agame. If we are the host, we just connect to the loopback address 127.0.0.1,otherwise, we need to connect to a pseudo-remote server. This means that in prac-tice, the server could still be running in the same machine if the user is testing twoclients in the same computer. However, if we are joining a server on another computer, we actually need a valid IP address. We get it from a file conveniently namedip.txt, which is created and saved in the same directory as the executable incase it doesn't exist, already containing the loopback address. Changing this file isthe way to go if you want to pick an arbitrary IP to connect to.
The port used is 5000 and it is hardcoded both in the server and the client. If youtry the application, make sure you don't have other games or programs conflictingwith this port


After attempting to connect with a timeout of five seconds, we either set the clientto a valid connected state, or we restart a clock that will timeout after another 5seconds, in the meantime showing the error message stating that connection wasnot possible.Most things in MultiplayerGameState are a direct copy of how GameStateused to work. Though there are some changes and additions we would like to men-tion. In the update() function, besides what was already there, we now check forincoming packets from the server

The handlePacket() function is very alike to the server's handleIncom-ingPacket() function.

Then we perform some logic to update the broadcast queue that shows the mes-sages from the server on the screen and the text that blinks prompting a secondplayer to join in by pressing the Return or Enter key:
＝＝＝＝＝＝＝＝
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-354.html


Synchronization issues
If you test this chapter's sample extensively enough, you will notice clear synchron-ization problems, where some things do not happen the exact same way for all cli-ents. This is intended and accounted for. We sacrificed a bit on the final polish levelof the networked simulation, so it could remain simple. We understand networkingis a very complex topic which might confuse even the brightest minds at first. Wecould never learn everything about it in one book, let alone in one chapter. There-fore, we went with an approach as simple as possible in this chapter. We wouldrather have you focused in learning the concepts we directly teach so you can ex-tend them later into a fully-polished game than to have a way bigger codebase tolook and get lost in.

Then we perform some logic to update the broadcast queue that shows the mes-sages from the server on the screen and the text that blinks prompting a secondplayer to join in by pressing the Return or Enter key:

Finally, we tick the client in the same way and rate we tick in the server. Instead ofsending a snapshot of all the local states, the client sends only the positions of itslocal aircraft:

=====
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-358.html

Client packets

Here's the protocol explanation for the client. The Client::PacketType enumcontains the following enumerators:

-  PlayerEvent: This takes two sf::Int32 variables, an aircraft iden-tifier, and the event to be triggered as defined in the Player class. 
It isused to request the server to trigger an event on the requested aircraft.
- Quit: This takes no parameters. It simply informs the server that thegame state is closing, so it can remove its aircraft immediately.
- PlayerRealtimeChange: This is the same as PlayerEvent, but ad-ditionally takes a Boolean variable to state whether the ongoing actionis active or not.
- RequestCoopPartner: This takes no parameters. It is sent when theuser presses the Return key to request the server a local partner. Its counterpart AcceptCoopPartner will contain all information to actu-ally do the spawn of the friendly unit.
- PositionUpdate: This is what we saw in the client's tick code. It takesa sf::Int32 variable with the number of local aircraft, and for eachaircraft, it packs another sf::Int32 variable for the identifier and twofloat values for the position.
- GameEvent: This packet informs the server of a specific happening inthe client's game logic, such as enemy explosions.Transmitting game actions via network nodes
Now, we will take a closer look at the GameEvent packet, which is sent when cer-tain actions in the game occur. 
We use it to notify about explosions of enemies ina way that pick-up dropping is synchronized among different clients (either, a pick-up drops at every client or not at all). However, our implementation allows you toextend it for any game action. 
First, we have a GameActions namespace whichcontains an enum to differ between the game actions, and a struct to store an action:


NetworkNode class
In Chapter 9, Cranking Up the Bass - Music and Sound Effects, you saw thatwe used a dedicated scene node class named SoundNode to build an interfacebetween command-based game events and another game component, in thatcase, the sound player. 
Here, we are repeating this approach: 
We create a NetworkNode class that lets objects in the scene directly send events over the network:


This class holds a queue of game actions that are going to be transmitted. 
ThenotifyGameAction() method inserts a new game action into the queue, 
whilepollGameAction() checks if an action is pending. 
If so, it pops the action fromthe queue and stores it in the output parameter—just as you know it from SFML'spollEvent() function.

Now, how does this look in practice? In the Aircraft::updateCurrent()method, we have a check if the current airplane has just exploded and if it's anenemy. In this case, we issue a command. The Category::Network category isthe receiver category of NetworkNode:


The network node itself is placed in the World class. AWorld::pollGameAction() member function acts as a pure forwarder and canbe used in other parts of the game where we only have access to the world, butnot its scene and entities.

One example is the MultiplayerGameState class. In its update() function,we interpret the game action and build a packet based on it, which is then sent overthe network. We fill the packet with the Client::GameEvent packet type, thegame action type (which in our case is always GameActions::EnemyExplode)and the position coordinates


On the server side, in GameServer::handleIncomingPacket(), this packetis interpreted. When the game action denotes an exploded enemy, a pick-up willbe spawned with a certain probability. This in turn leads to a packet of type Serv-er::SpawnPickup, which is distributed to all clients

======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-361.html

The new pause state

For this chapter, the pause state was slightly modified. The same PauseStateclass was now modified to accept an option in its constructor to either allow or denyunderlying states from being updated. The "default" behavior didn't change, but ifwe pass this parameter as true, the underlying states keep updating. This was anecessity as there was no concept of pausing in a networked game, because theworld is persistent. However, the user may still want to access settings or go backto the main menu!

======
Settings
You may now configure two sets of keys in the Settings screen! This was done bynot using an application wide Player instance anymore, rather by using a prop-er KeyBinding structure, holding the keys that are later passed to Player in-stances at will.

======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-362.html

The new Player class

The Player class needed to be reworked quite a bit in order to support a mul-tiplayer mode. Players are not hardcoded anymore in a state context scope, butrather, there is one player for each human-controlled aircraft in the world.Every player is now identified by the same identifier that classifies one aircraft, sothey can be paired up fast. Also, the constructor of Player now looks like the following:


We pass on a socket instance or a nullptr, defining whether the Player classis being used in a networked or a single-player game. This socket, if passed, isvalid for sending data to the server, which we will do next!

The identifier is exactly what you'd expect, the same that maps to an aircraft too.
Finally, we also have KeyBinding being passed here. We will be passing it threedifferent things: The defined keys for the player 1, player 2, and nullptr in casethis Player instance does not receive local input, but rather is controlled by theserver!

As for event and input handling by the Player class, it now works a little differentlytoo.

Now, the real-time input is only delivered to the local player aircraft—the ones withactual human players controlling them. In consequence, each client has total con-trol over its planes along with immediate responsiveness and smoothness. At thesame time, that input is sent to the server, so every client is aware of that move-ment.

=======
https://www.google.com/search?q=%E7%BF%BB%E8%A8%B3&oq=&aqs=chrome.2.35i39l8.262022j0j7&sourceid=chrome&ie=UTF-8

Latency

Programming and maintaining efficient server software is already a very hard task;however, to add even more complexity to this duty, we must deal with latency too.This topic is very broad but we will still try to give you some starting tips on how todeal with these issues.Roughly, latency is the delay a network packet takes to reach its destination. Thebigger the latency, the more we get behind in the networked simulation, and in con-sequence, the gameplay gets worse.This little nightmare is one of the hardest troubles to deal with in network program-ming. It will make players have a different experience based on their connectionand other network conditions, that is, it will make the game very smooth for someplayers while completely unplayable for others; it will be a mess. Unfortunately, it isnot in the hands of the programmer to deal with the network's latency at all. A pro-grammer can at best prepare the software to behave a little better in the worst casescenarios, where the latency is high. This is usually a very hard task to get right andis one of the main reasons game development companies need specialized and ex-perienced network programmers to achieve a good simulation for all players, inde-pendently of how bad their connection is, within reasonable limits. Latency becomesa more and more determining factor as the geographical distance between peers in-creases. Already the speed-of-light delay between different continents of the Earthamounts to a fraction of a second, router logic on the way through the Internet mayadd even more. Until a peer receives an answer, data must be sent to the otherpeers and back; thus, we have the delay of both ways (also called round-trip time).Therefore, physics significantly limits the way how multiplayer games can be playedacross large distances.

=======
Latency versus  bandwidth

 not confuse latency with bandwidth: The former denotes the time delay, whilethe latter denotes the capacity of the link. If you imagine a link as a pipe, the latencyis related to its length, and thus to the time the water requires to flow through it.Bandwidth however is determined by the cross-section of the pipe; it specifies howmuch water can flow through it in a certain amount of time.


You cannot make a single bit arrive faster by increasing the bandwidth. What youcan do however is to send many bits in parallel, so that a bigger chunk of data stillneeds less time to be transmitted. 
The bandwidth determines how much data youcan send in a certain amount of time.


======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-364.html

View scrolling compensation

The view is now simulated both in the client and the server and updated at thesame speed in both of them. However, since the updates are happening in differ-ent threads or even different machines, some discrepancies may occur occasion-ally. Also, when a new player joins the game, he has to be informed of how far theview currently is, so it can keep up with it. In order to keep the view synchronizedbetween all clients and the server, the server will send the view's position in everytick and the clients will employ a little trick to smoothly resynchronize the view.The trick is simple. When the view is scrolled, we multiply the scroll offset with acompensation factor:

mWorldView.move(0.f, mScrollSpeed *dt.asSeconds() *mScrollSpeedCompensation);

Now we just need to ensure that the factor is 1 when the views are in sync, andvary it, so the view scrolls faster or slower depending on how distanced it is fromthe server's view position. We do this by dividing both positions whenever we getthe update:mWorld.setWorldScrollCompensation(currentViewPosition/    currentWorldPosition);This will keep the view synchronized while never losing smoothness, unlesssomething is very wrong and is too far behind, which should never happen in nor-mal circumstances.


======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-365.html

Aircraft interpolation

After the compensation technique, we decided to implement another little trick forthe aircraft synchronization. Again, this is a simple way to achieve synchronizationand it doesn't give the smoothest results most often. We still wrote it so you couldface different algorithms and techniques and hopefully learn from them.Remember, that each client commands its own planes and just informs the serverof what is happening locally. With this information, the server keeps track of whereevery aircraft that is located. In every tick, it sends that information to its peers sothey can synchronize with the true simulation data.The planes would move quite accurately anyway with the real-time input inform-ation that comes from the server, but still some desynchronization could happeneventually. Because of this, when we get the real position of the aircraft in everytick, we move our aircraft slowly into that position, so, at best, after some ticks theaircraft are completely synchronized:

if (aircraft && !isLocalPlane){sf::Vector2f interpolatedPosition =aircraft->getPosition() + (aircraftPosition -aircraft->getPosition()) * 0.1f;aircraft->setPosition(interpolatedPosition);}

The logic is simple. If the aircraft belongs to a remote player, we will interpolateits position between the current local position and the server's position (air-craftPosition). We have hardcoded an interpolation "amount" of 0.1f, whichmeans that we will always move 10 percent of the distance between both positions.
This small value avoids having the aircraft "jump" from place to place, exceptwhen the network conditions are really bad and the synchronization is suffering toomuch.


=======
http://nedrilad.com/Tutorial/topic-32/SFML-Game-Development-366.html

Cheating prevention

By now you probably are scratching your chin and asking yourself: "But is this se-cure? Is a hacky player able to exploit the game to its benefit somehow?"If you answered "No" to yourself, you are correct. By all means we would like to ex-plain you how to make every little thing cheat-proof. However, we don't want to giveyou the fish by bloating the code with lots of validations; but rather, explicitly writingabout how you can learn how to fish.
The current game, as is, is not cheat-proof whatsoever. 
There are a lot of validationsthat are not performed, so it will only work predictably until a clever user starts doingpacket-sniffing and sending things that are not really expected by our protocol.Let's try to understand how cheating could be achieved in our particular case, andhow would we prevent it by looking at a few examples:

- In the client's tick, we let the client decide where its planes are going tobe at. 
If a user with malicious intent sent this packet after modifying, hewould be able to position its aircraft in any location, effectively warpingfrom place to place as much as he wanted. We would fix this by not ac-cepting the new positions in the server without some validations first. 
We would need to check if the new position is possible. Whether it could beachieved with normal gameplay, given the aircraft velocity and previouspositions. 
Right here we could spot on a cheater and act upon it by ban-ning or kicking or simply logging what happened to a file.
- Another great example of how we could exploit this game is to look atthe PlayerEvent packet on the client-side. 
It carries an aircraft identifi-er and an action to perform. 
However, as the server doesn't check if theidentifier sent is owned by that peer, a malicious user could effectivelymake other people's planes shoot bullets and missiles.
We intentionally left such things uncovered so you could see how serious it can beif you don't check all the data coming from a client. Users will often try to break theserver state for an in-game profit.The golden rule to prevent cheating is, when handling a packet in the server, alwaysask yourself if what the client is requesting is possible! Do as many validations as

possible in the server's logic. The ultimate goal for a safe online simulation isreaching that point when there is no possible combination of data coming fromthe client that will produce unpredicted results. Always remember, as long as theserver's state is sane and controlled, there is no cheating, as hard as it may be toachieve this.

======
cd /Users/ohwada/C++_SFML-Game-Development-Book


SFML-Game-Development-Book
https://github.com/SFML/SFML-Game-Development-Book

 Game Development By Example
https://www.amazon.co.jp/SFML-Game-Development-Example-English-ebook/dp/B01061QAH4


