
cd /Users/ohwada/C++_SFML-Game-Development-Book/06_Menus

g++ Source/*.cpp  -std=c++11 `pkg-config --cflags --libs sfml-all`  -I./Include 

＝＝＝＝＝


Chapter 6. Waiting and Maintenance Area – Menus 
Most games have menus and it's something the player expects when opening up a new game.

Even in its simplest form, there is a user interface that responds to the user, and gives him the information he needs to enjoy the game. You might have noticed that we implemented a simple menu in the previous chapter, but it's a prime example where you should refactor and extract into its own class. This is what we will do in this chapter: Design a user interface components hierarchy

- Design a user interface components hierarchy 
- Implement the base component class 
- Implement containers, labels, and buttons 
- Create a proper title screen 
- Create a settings screen


=====
The GUI hierarchy, the Java way 
The architecture for the GUI framework will resemble a lot of other toolkits such as Java's Swing/AWT library as it's a well working concept. 

Note that it is not exactly reproduced, rather is used as a source of inspiration. In the end, what we aim to achieve is a working menu state based on this design, but without pumping the state full of boilerplate GUI code.




We create a namespace GUI in order to make the distinction clear to other parts of our game, since a lot of the names such as "component" are generic, and can be misinterpreted easily. 
We start with one core base class, which the entire hierarchy rests on. We call it Component and in objects.



our case it is quite small. It defines the interface that we will be using regularly besides setting up the objects. The class defines a couple of virtual functions, one of which is the handleEvent() function. We let the Component class inherit from sf::Drawable for the same reason as the scene nodes. To have an interface for drawing to an SFML window:





You might be wondering about the pure virtual isSelectable() function and the other virtual ones. 
They exist for buttons and containers. 
For the moment, you can just assume that isSelectable() returns false, and that the virtual ones are based on the two variables with similar names. 
The core for the GUI is the Component::handleEvent() function because this is where the magic happens. 
The typedef of a shared pointer of Component to the name Component::Ptr is for convenience purposes. 
You don't need it, but it makes code more readable, by simplifying the name we use.




=====
Updating the menu 
So, let's see our code in actual use. Do you remember MenuState from the previous chapter? There we implemented some menu logic, so you could choose between two options. Now this can be cleaned up a lot; as a result the menu state shrinks drastically.


The constructor initializes the buttons and packs them into the Container. As you can see, the lambda expression we give to the Button is the place where we actually describe the action we want the button to do. 
The rest of the functions are changed to use the GUI container to render and handle events.



=====
The promised key bindings 
We implement a new state; the SettingsState which you access through a button on the menu. What is the purpose for the SettingsState in our example? Currently we have the key bindings inside there. Everything we need has already been implemented with the GUI, so we only have to define the actual state.


We have put all the binding buttons and the associated labels in a static array, and associate to them the action they bind for. This means we don't have to duplicate a lot of callbacks, which you may have notice are missing. Instead, we have marked the button as one that toggles. We also have an updateLabels() function call. It's a helper function to make sure the labels are writing out the correct name for the key.



If a button is pressed, then it will be activated, and since it's a button that toggles, it will stay active until we tell it to deactivate. So we loop through the array of buttons and check if anyone of them is active. If they are, then we are currently binding a key. When we get a key released event, then we change that binding on the player to the new key with the specified action before we deactivate the button again. After the loop, we update the labels, such that they have the correct name for everything. If no button is active, then we are not currently trying to bind a key, and should pass the event to the GUI container instead.










======
Introducing SFML 
Before we start developing a game, we would like to tell you a little bit about the library we will use throughout the book. SFML is an object-oriented C++ framework.

 A minimal example 
Before you go deeper into the book and SFML itself, let's take a look at a minimal application example to show how an application that uses this library looks like, its general flow of execution, and some basic functionality.

Developing the first game Now that we got the boring parts finished, we can finally start making a game. So where do we start? What do we do first? First, you should have an idea of what kind of game you want to develop, and what elements it will incorporate. For the purpose of this book, we have chosen to create a shoot-em-up game. The player controls an aircraft viewed from the top, and has to find its way through a level full of enemies.

Displaying sprites on the screen 
Now let's get something interesting on the screen. Instead of just rendering a boring single color circle to the screen, let's actually render an image. To do this, SFML provides a couple of tools to make your life easy. First we have the sf::Texture class that holds the actual image data loaded from the hard drive. Next is the sf::Sprite class that represents an instance with position and orientation in the scene. The texture describes the image, while the sprite describes where and how to put one on the screen.


====

cd /Users/ohwada/C++_SFML-Game-Development-Book


SFML-Game-Development-Book
https://github.com/SFML/SFML-Game-Development-Book

 Game Development By Example
https://www.amazon.co.jp/SFML-Game-Development-Example-English-ebook/dp/B01061QAH4


